import { Directory, Encoding, Filesystem } from '@capacitor/filesystem';
import { Share } from '@capacitor/share';
import { InAppBrowser, ToolBarType } from '@capgo/inappbrowser';

import { isMobile } from 'lib/platform';

const DOWNLOAD_INTERCEPTOR_SCRIPT = `
(function() {
  if (window.__downloadInterceptorInjected) return;
  window.__downloadInterceptorInjected = true;

  // Store blob URLs and their base64 content
  const blobRegistry = new Map();

  // Helper to convert ArrayBuffer to base64
  function arrayBufferToBase64(buffer) {
    let binary = '';
    const bytes = new Uint8Array(buffer);
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }

  // Override URL.createObjectURL to capture blob content as base64
  const originalCreateObjectURL = URL.createObjectURL;
  URL.createObjectURL = function(blob) {
    const url = originalCreateObjectURL.call(this, blob);
    if (blob instanceof Blob) {
      blob.arrayBuffer().then(buffer => {
        const base64 = arrayBufferToBase64(buffer);
        blobRegistry.set(url, base64);
      }).catch(() => {});
    }
    return url;
  };

  function handleDownload(href, filename) {
    // Check if we have the blob content cached
    if (blobRegistry.has(href)) {
      const base64Content = blobRegistry.get(href);
      window.mobileApp.postMessage({
        detail: {
          type: 'DOWNLOAD_FILE',
          filename: filename,
          content: base64Content,
          isBase64: true
        }
      });
      return;
    }

    // Fallback to fetching as binary
    fetch(href)
      .then(r => r.arrayBuffer())
      .then(buffer => {
        const base64Content = arrayBufferToBase64(buffer);
        window.mobileApp.postMessage({
          detail: {
            type: 'DOWNLOAD_FILE',
            filename: filename,
            content: base64Content,
            isBase64: true
          }
        });
      })
      .catch(err => console.error('Download error:', err));
  }

  // Intercept programmatic clicks on anchor elements
  const originalClick = HTMLAnchorElement.prototype.click;
  HTMLAnchorElement.prototype.click = function() {
    if (this.hasAttribute('download')) {
      const href = this.href;
      const filename = this.download || 'download';
      handleDownload(href, filename);
      return;
    }
    return originalClick.apply(this, arguments);
  };

  // Intercept manual clicks on <a download> links
  document.addEventListener('click', function(e) {
    const link = e.target.closest('a[download]');
    if (link) {
      e.preventDefault();
      e.stopPropagation();
      handleDownload(link.href, link.download || 'download');
    }
  }, true);

  // Watch for "TOKENS MINTED!" success message and auto-close browser
  let successMessageSent = false;
  function checkForSuccessMessage() {
    if (successMessageSent) return;
    const bodyText = document.body ? document.body.innerText : '';
    if (bodyText.includes('TOKENS MINTED!') && bodyText.includes('CLICK ANYWHERE TO CONTINUE')) {
      successMessageSent = true;
      // Small delay so user can see the success message
      setTimeout(() => {
        window.mobileApp.postMessage({
          detail: { type: 'PUBLIC_NOTE_SUCCESS' }
        });
      }, 750);
    }
  }

  // Use MutationObserver to detect DOM changes
  const observer = new MutationObserver(checkForSuccessMessage);
  if (document.body) {
    observer.observe(document.body, { childList: true, subtree: true, characterData: true });
  } else {
    document.addEventListener('DOMContentLoaded', function() {
      observer.observe(document.body, { childList: true, subtree: true, characterData: true });
    });
  }

  // Also poll periodically as a fallback
  setInterval(checkForSuccessMessage, 1000);
})();
`;

// Allowed faucet domains for script injection (App Store compliance)
const FAUCET_DOMAINS = ['faucet.testnet.miden.io', 'faucet.devnet.miden.io', 'localhost'];

export interface FaucetWebviewOptions {
  url: string;
  title: string;
  recipientAddress?: string;
}

export async function openFaucetWebview({ url, title, recipientAddress }: FaucetWebviewOptions): Promise<void> {
  if (!isMobile()) {
    window.open(url, '_blank');
    return;
  }

  // Script to prefill the recipient address input
  const prefillAddressScript = recipientAddress
    ? `
    (function() {
      const input = document.getElementById('recipient-address');
      if (input) {
        input.value = '${recipientAddress}';
        input.dispatchEvent(new Event('input', { bubbles: true }));
      }
    })();
    `
    : '';

  // Guard to prevent duplicate download processing
  let isProcessingDownload = false;

  // Set up message listener for download requests
  const messageListener = await InAppBrowser.addListener('messageFromWebview', async event => {
    try {
      // The event should directly contain our data since notifyListeners passes messageBody as data
      const eventData = event as { detail?: { type?: string; filename?: string; content?: string } };
      const detail = eventData.detail;

      if (!detail) {
        return;
      }

      if (detail.type === 'DOWNLOAD_FILE') {
        // Prevent duplicate processing
        if (isProcessingDownload) {
          return;
        }
        isProcessingDownload = true;
        const { filename, content } = detail;

        // Write to cache directory as base64 (no encoding = binary/base64)
        const result = await Filesystem.writeFile({
          path: filename,
          data: content,
          directory: Directory.Cache
        });

        // Store the URI for later sharing
        const fileUri = result.uri;
        const fileTitle = filename;

        // Close browser first
        await InAppBrowser.close();

        // Use setTimeout to completely decouple share from InAppBrowser context
        setTimeout(async () => {
          try {
            await Share.share({
              files: [fileUri],
              dialogTitle: 'Save ' + fileTitle
            });
          } catch (e) {
            alert('Share error: ' + (e as Error).message);
          }
        }, 1000);
      }

      if (detail.type === 'PUBLIC_NOTE_SUCCESS') {
        // Auto-close browser when public note minting is complete
        await InAppBrowser.close();
      }
    } catch (error) {
      // Show alert with error for debugging
      if (typeof alert !== 'undefined') {
        alert('Error: ' + (error as Error).message);
      }
    }
  });

  // Inject prefill script when page loads (needs DOM to be ready)
  const loadListener = await InAppBrowser.addListener('browserPageLoaded', async () => {
    try {
      if (prefillAddressScript) {
        await InAppBrowser.executeScript({ code: prefillAddressScript });
      }
    } catch (e) {
      console.error('[FaucetWebview] Error injecting prefill script:', e);
    }
  });

  // Clean up listeners when browser closes
  const closeListener = await InAppBrowser.addListener('closeEvent', () => {
    messageListener.remove();
    loadListener.remove();
    closeListener.remove();
  });

  // Open the webview with download interceptor injected at document start
  await InAppBrowser.openWebView({
    url,
    title,
    toolbarType: ToolBarType.NAVIGATION,
    showReloadButton: true,
    isPresentAfterPageLoad: true,
    preShowScript: DOWNLOAD_INTERCEPTOR_SCRIPT,
    preShowScriptInjectionTime: 'documentStart'
  });
}
