import { Address, BasicFungibleFaucetComponent, Endpoint, RpcClient } from '@miden-sdk/miden-sdk';

import { isMidenAsset } from 'lib/miden/assets';

import { DEFAULT_TOKEN_METADATA, getAssetUrl, MIDEN_METADATA } from './defaults';
import { AssetMetadata, DetailedAssetMetdata } from './types';

export async function fetchTokenMetadata(
  assetId: string
): Promise<{ base: AssetMetadata; detailed: DetailedAssetMetdata }> {
  if (isMidenAsset(assetId)) {
    return { base: MIDEN_METADATA, detailed: MIDEN_METADATA };
  }

  try {
    const endpoint = Endpoint.testnet();
    const rpcClient = new RpcClient(endpoint);
    const account = await rpcClient.getAccountDetails(Address.fromBech32(assetId).accountId());
    const underlyingAccount = account.account();
    if (!underlyingAccount) {
      if (account.isPublic()) {
        // if the account was public and we couldn't fetch metadata it should not happen in first place
        // but in case it does we are storing it as unknown metadata and warning in console
        console.warn('Failed to fetch metadata from chain for', assetId, 'Using default metadata');
      }
      // if the account is private we are assigning it the unknown metadata, as there is no way to fetch the metadata from chain
      return { base: DEFAULT_TOKEN_METADATA, detailed: DEFAULT_TOKEN_METADATA };
    }
    const faucetDetails = BasicFungibleFaucetComponent.fromAccount(underlyingAccount);
    const decimals = faucetDetails.decimals();
    const symbol = faucetDetails.symbol().toString();
    const base: AssetMetadata = {
      decimals,
      symbol,
      name: symbol,
      shouldPreferSymbol: true,
      thumbnailUri: getAssetUrl('misc/token-logos/default.svg')
    };

    const detailed: DetailedAssetMetdata = {
      ...base
    };

    return { base, detailed };
  } catch (err: any) {
    console.error(err);

    throw new NotFoundTokenMetadata();
  }
}

export class NotFoundTokenMetadata extends Error {
  name = 'NotFoundTokenMetadata';
  message = 'Metadata for token not found';
}
